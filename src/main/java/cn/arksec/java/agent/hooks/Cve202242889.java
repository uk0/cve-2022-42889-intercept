
package cn.arksec.java.agent.hooks;

import net.bytebuddy.agent.builder.AgentBuilder;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.asm.AsmVisitorWrapper;
import net.bytebuddy.description.method.MethodList;
import net.bytebuddy.matcher.ElementMatcher;
import net.bytebuddy.matcher.ElementMatchers;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.utility.JavaModule;
import java.security.ProtectionDomain;
import net.bytebuddy.description.method.MethodDescription;
import java.util.HashMap;
import java.lang.instrument.Instrumentation;

/**
 * @auther firsh.me
 * @2022-10-210
 */
public class Cve202242889 {


    @Advice.OnMethodEnter(inline = true, skipOn = Advice.OnNonDefaultValue.class)
    static String enter(@Advice.This Object _this, @Advice.Argument(readOnly = true, value = 0) String key) {
        System.err.println("[CVE 2022-42889] StringSubstitutor" + _this.getClass() + ": (sanitized) " + key.replace("$", "%").replace("{", "_").replace("}", "_"));
        return "(StringSubstitutor replace disabled)";
    }

    @Advice.OnMethodExit(inline = true, onThrowable = Exception.class)
    static void exit(@Advice.Enter String enter_return, @Advice.Return(readOnly = false) String ret) {
        ret = enter_return;
    }

    static AsmVisitorWrapper getVisitor() {
        return Advice.to(Cve202242889.class).on(
                ElementMatchers.named("replace")
                        .and(
                                ElementMatchers.takesArguments(1).and(ElementMatchers.takesArgument(0, String.class))
                        )
        );
    }

    private static final String TARGET = "org.apache.commons.text.StringSubstitutor";

    public static void hook(Instrumentation inst) {
        new AgentBuilder.Default()
                .disableClassFormatChanges()
                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
                .ignore(ElementMatchers.none())
                .type(new ElementMatcher<TypeDescription>() {
                    public boolean matches(TypeDescription target) {
                        if (target != null) {
                            String cn = target.getCanonicalName();
                            if (cn != null) {
                                return TARGET.equals(cn);
            /*if (cn.endsWith(TARGET)) {
              return TARGET.equals(cn) || cn.endsWith(SUFFIX_TARGET);
            }*/
                            }
                        }
                        return false;
                    }
                })
                .transform(new AgentBuilder.Transformer() {
                    @Override
                    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule, ProtectionDomain protectionDomain) {
                        try {
                            //System.out.println("[log4j-jndi-be-gone] class found!: " + td);
                            return builder.visit(Cve202242889.getVisitor());
                        } catch (Throwable t) {
                            t.printStackTrace();
                            return builder;
                        }
                    }
                })
                .installOn(inst);
    }


    // we assume that the entire "org.apache.logging.log4j.core" package prefix
    // could be swapped out because that is the max length prefix for
    // https://github.com/apache/logging-log4j2 from 2.0 to 2.16.0
    // (though we only really care about 2.0-2.15.0)
    private static final String LCD_TARGET = "text.StringSubstitutor";
    private static final String LCD_SUFFIX_TARGET = ".text.StringSubstitutor";

    public static void hook_deep_match(Instrumentation inst) {
        System.out.println("cve-2022-42889 check start");
        new AgentBuilder.Default()
                .disableClassFormatChanges()
                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
                .ignore(ElementMatchers.none())
                .type(new ElementMatcher<TypeDescription>() {
                    public boolean matches(TypeDescription target) {
                        if (target != null) {
                            String cn = target.getCanonicalName();
//          System.out.println("cve-2022-42889 getCanonicalName  "+cn);
                            if (cn != null) {
                                if (cn.endsWith(LCD_TARGET)) {
                                    if (LCD_TARGET.equals(cn) || cn.endsWith(LCD_SUFFIX_TARGET)) {
                                        try {
                                            System.out.println("cve-2022-42889 is_deep_match  " + cn);
                                            return is_deep_match(target);
                                        } catch (Throwable t) {
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                        return false;
                    }
                })
                .transform(new AgentBuilder.Transformer() {
                    @Override
                    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule, ProtectionDomain protectionDomain) {
                        try {
                            System.out.println("[cve-2022-42899] class found!: " + typeDescription);
                            return builder.visit(Cve202242889.getVisitor());
                        } catch (Throwable t) {
                            t.printStackTrace();
                            return builder;
                        }
                    }
                })
                .installOn(inst);
    }

    public static boolean is_deep_match(TypeDescription target) {
        MethodList<MethodDescription.InDefinedShape> methodList = target.getDeclaredMethods();
//    System.out.println("methodList.Size()  " + methodList.size());


        HashMap<String, MethodDescription.InDefinedShape> pm = new HashMap<String, MethodDescription.InDefinedShape>();
        for (MethodDescription.InDefinedShape md : methodList) {

            if ("replace".equals(md.getName())) {
//        System.out.println("md.getParameters().size()  = "+md.getParameters().size());
                if (md.getParameters().size() != 1) {
                    continue;
                }
            }
            pm.put(md.getActualName(), md);
        }

//    System.out.println("pm  = "+pm.containsKey("replace"));

        if (!pm.containsKey("replace")) {

            return false;
        } else {

            MethodDescription.InDefinedShape md = pm.get("replace");
            System.out.println("md.getReturnType().getActualName() " + md.getReturnType().getActualName());
            if (!"java.lang.String".equals(md.getReturnType().getActualName())) {
                return false;
            }
        }
        return true;
    }

}
